{
"version":3,
"file":"testt.js",
"lineCount":49,
"mappings":"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",
"sources":["node_modules/fs/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/erotic/node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/@wrote/wrote/node_modules/@wrote/write/src/index.js","t/wrote/w.js"],
"sourcesContent":["const fs = require('fs')\n\nexport default fs\nexport const {\n  'F_OK': F_OK,\n  'FileReadStream': FileReadStream,\n  'FileWriteStream': FileWriteStream,\n  'R_OK': R_OK,\n  'ReadStream': ReadStream,\n  'Stats': Stats,\n  'W_OK': W_OK,\n  'WriteStream': WriteStream,\n  'X_OK': X_OK,\n  'access': access,\n  'accessSync': accessSync,\n  'appendFile': appendFile,\n  'appendFileSync': appendFileSync,\n  'chmod': chmod,\n  'chmodSync': chmodSync,\n  'chown': chown,\n  'chownSync': chownSync,\n  'close': close,\n  'closeSync': closeSync,\n  'constants': constants,\n  'copyFile': copyFile,\n  'copyFileSync': copyFileSync,\n  'createReadStream': createReadStream,\n  'createWriteStream': createWriteStream,\n  'exists': exists,\n  'existsSync': existsSync,\n  'fchmod': fchmod,\n  'fchmodSync': fchmodSync,\n  'fchown': fchown,\n  'fchownSync': fchownSync,\n  'fdatasync': fdatasync,\n  'fdatasyncSync': fdatasyncSync,\n  'fstat': fstat,\n  'fstatSync': fstatSync,\n  'fsync': fsync,\n  'fsyncSync': fsyncSync,\n  'ftruncate': ftruncate,\n  'ftruncateSync': ftruncateSync,\n  'futimes': futimes,\n  'futimesSync': futimesSync,\n  'lchmod': lchmod,\n  'lchmodSync': lchmodSync,\n  'lchown': lchown,\n  'lchownSync': lchownSync,\n  'link': link,\n  'linkSync': linkSync,\n  'lstat': lstat,\n  'lstatSync': lstatSync,\n  'mkdir': mkdir,\n  'mkdirSync': mkdirSync,\n  'mkdtemp': mkdtemp,\n  'mkdtempSync': mkdtempSync,\n  'open': open,\n  'openSync': openSync,\n  'read': read,\n  'readFile': readFile,\n  'readFileSync': readFileSync,\n  'readSync': readSync,\n  'readdir': readdir,\n  'readdirSync': readdirSync,\n  'readlink': readlink,\n  'readlinkSync': readlinkSync,\n  'realpath': realpath,\n  'realpathSync': realpathSync,\n  'rename': rename,\n  'renameSync': renameSync,\n  'rmdir': rmdir,\n  'rmdirSync': rmdirSync,\n  'stat': stat,\n  'statSync': statSync,\n  'symlink': symlink,\n  'symlinkSync': symlinkSync,\n  'truncate': truncate,\n  'truncateSync': truncateSync,\n  'unlink': unlink,\n  'unlinkSync': unlinkSync,\n  'unwatchFile': unwatchFile,\n  'utimes': utimes,\n  'utimesSync': utimesSync,\n  'watch': watch,\n  'watchFile': watchFile,\n  'write': write,\n  'writeFile': writeFile,\n  'writeFileSync': writeFileSync,\n  'writeSync': writeSync,\n} = fs","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : Number.Infinity)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {number} [transparent] trim the top line as well\n * @returns {string} A part of stack\n * @private\n */\nexport const getEntryStack = (stack, transparent) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {arguments} args arguments\n * @returns {function} The caller function from `arguments.callee.caller`.\n * @private\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","const os = require('os')\n\nexport default os\nexport const {\n  'EOL': EOL,\n  'arch': arch,\n  'constants': constants,\n  'cpus': cpus,\n  'endianness': endianness,\n  'freemem': freemem,\n  'getNetworkInterfaces': getNetworkInterfaces,\n  'homedir': homedir,\n  'hostname': hostname,\n  'loadavg': loadavg,\n  'networkInterfaces': networkInterfaces,\n  'platform': platform,\n  'release': release,\n  'tmpDir': tmpDir,\n  'tmpdir': tmpdir,\n  'totalmem': totalmem,\n  'type': type,\n  'uptime': uptime,\n  'userInfo': userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.js lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {Config} options Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {string[]} [options.ignoreModules=\"['pirates']\"] Which modules to ignore in the path. Default `['pirates']`.\n */\nconst cleanStack = (stack, options = {}) => {\n  const {\n    pretty = false,\n    ignoredModules = ['pirates'],\n  } = options\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim() !== '')\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @typedef {Object} Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {string[]} [ignoreModules=\"['pirates']\"] Which modules to ignore in the path. Default `['pirates']`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback\n * @function makeCallback\n * @param {function} entryCaller function which was called at entry\n * @param {string} entryStack first line of the error stack to be returned\n * @param {boolean} [shadow=false] print only entry stack\n * @private\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return Object.assign(e, properties)\n  }\n\n  return cb\n}\n","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","import { createWriteStream } from 'fs'\nimport erotic from 'erotic'\n\n/**\n * Write a file to the filesystem.\n * @param {string} path The path of the file to write.\n * @param {string|Buffer} data The data to write.\n */\nexport default async function write(path, data) {\n  if (!path) throw new Error('No path is given.')\n  const er = erotic(true)\n  const ws = createWriteStream(path)\n  await new Promise((r, j) => {\n    ws\n      .on('error', (e) => {\n        const err = er(e)\n        j(err)\n      })\n      .on('close', r)\n      .end(data)\n  })\n}","import write from '@wrote/wrote/node_modules/@wrote/write'\n\n(async () => {\n  await write('test.js', 'data')\n})()"],
"names":["fs","require","createWriteStream","getStackSegment","stack","from","oneLine","splitStack","split","Number","Infinity","item","length","slice","items","join","getCallerFromArguments","args","caller","os","homedir","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","options","re","RegExp","source","replace","j","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","transparent","stackSegment","write","er","ws","path","Promise","r","on","err","end","data"]
}
